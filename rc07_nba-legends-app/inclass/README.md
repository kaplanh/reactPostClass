# React Bootstrap

[DÃ¶kÃ¼manÄ± gÃ¶rÃ¼ntÃ¼lemek iÃ§in tÄ±klayÄ±nÄ±z](https://react-bootstrap.netlify.app/docs/getting-started/introduction) <br>
[React Bootstrap Componentlerini gÃ¶rmek iÃ§in tÄ±klayÄ±nÄ±z](https://react-bootstrap.netlify.app/docs/components/accordion)
[React Bootstrap Componentlerini gÃ¶rmek iÃ§in tÄ±klayÄ±nÄ±z](https://react-bootstrap.netlify.app/docs/layout/grid)

React Bootstrap, popÃ¼ler bir UI (KullanÄ±cÄ± ArayÃ¼zÃ¼) bileÅŸen kitaplÄ±ÄŸÄ± olan Bootstrap'in React uygulamalarÄ±nda kullanÄ±lmasÄ±nÄ± saÄŸlayan bir entegrasyon kitidir.

React-Bootstrap, Bootstrap bileÅŸenlerinin React kullanÄ±larak tamamen yeniden uygulanmasÄ±dÄ±r. Bootstrap.js ya da jQuery'ye baÄŸÄ±mlÄ±lÄ±ÄŸÄ± yoktur. React kurulumunuz varsa ve React-Bootstrap yÃ¼klÃ¼yse, ihtiyacÄ±nÄ±z olan her ÅŸeye sahipsiniz demektir.

JsDom veya jQuery kullanan yÃ¶ntemler ve olaylar, DOM'u doÄŸrudan manipÃ¼le ederek zorunlu olarak yapÄ±lÄ±r. Buna karÅŸÄ±lÄ±k React, sanal DOM'u gÃ¼ncellemek iÃ§in durum gÃ¼ncellemelerini kullanÄ±r. Bu ÅŸekilde, React-Bootstrap, Bootstrap iÅŸlevselliÄŸini React'in sanal DOM'una dahil ederek daha gÃ¼venilir bir Ã§Ã¶zÃ¼m saÄŸlar.

React Bootstrap'i kullanmak iÃ§in, React uygulamanÄ±za ilgili paketi (package) eklemeniz ve belgelere gÃ¶re bileÅŸenleri kullanmanÄ±z gerekir. Projenizin baÄŸÄ±mlÄ±lÄ±klarÄ±na React Bootstrap'i ekledikten sonra, Ã¶rneklerde veya belgelerde verilen bileÅŸenleri kullanarak uygulamanÄ±za istediÄŸiniz tasarÄ±mÄ± ekleyebilirsiniz.

- BileÅŸen TabanlÄ± YapÄ±: React, bileÅŸen tabanlÄ± bir JavaScript kÃ¼tÃ¼phanesidir. React Bootstrap, bu bileÅŸen tabanlÄ± yapÄ±nÄ±n Ã¼zerine inÅŸa edilmiÅŸtir. BileÅŸenler, kullanÄ±cÄ± arayÃ¼zÃ¼nÃ¼zdeki farklÄ± parÃ§alarÄ± temsil eder ve yeniden kullanÄ±labilirlik saÄŸlar. React Bootstrap, Bootstrap bileÅŸenlerini React bileÅŸenleri olarak uygulamalarÄ±nÄ±za entegre etmenizi saÄŸlar. Ã–rneÄŸin, bir Button bileÅŸeni, React Bootstrap ile kolayca oluÅŸturulabilir ve kullanÄ±labilir.

- Bootstrap BileÅŸenlerinin React Uyumlu Hale Getirilmesi: Bootstrap, popÃ¼ler bir UI framework'tÃ¼r ve birÃ§ok kullanÄ±ÅŸlÄ± bileÅŸen iÃ§erir. Ancak, Bootstrap orijinal haliyle React projelerinde doÄŸrudan kullanÄ±lamaz. React Bootstrap, Bootstrap bileÅŸenlerini React uyumlu hale getirir ve bu bileÅŸenlerin React bileÅŸenlerinin avantajlarÄ±nÄ± kullanmanÄ±za olanak saÄŸlar. Ã–rneÄŸin, React bileÅŸenlerinde durum yÃ¶netimi kullanarak, dinamik ve etkileÅŸimli bileÅŸenler oluÅŸturabilirsiniz.

- DÃ¶kÃ¼mantasyon ve Ã–rnekler: React Bootstrap, kullanÄ±cÄ±larÄ±nÄ±n projelerine kolayca baÅŸlamalarÄ±nÄ± saÄŸlamak iÃ§in kapsamlÄ± bir dÃ¶kÃ¼mantasyon ve Ã¶rnekler sunar. DÃ¶kÃ¼mantasyon, React Bootstrap'in nasÄ±l kurulacaÄŸÄ±nÄ±, kullanÄ±lacak bileÅŸenlerin Ã¶zelliklerini ve nasÄ±l kullanÄ±lacaÄŸÄ±nÄ± aÃ§Ä±klar. Ã–rnekler, tipik kullanÄ±m senaryolarÄ±nÄ± gÃ¶sterir ve baÅŸlangÄ±Ã§ noktasÄ± olarak kullanÄ±labilir. Bu ÅŸekilde, React Bootstrap'i projenize entegre etmek ve bileÅŸenleri doÄŸru ÅŸekilde kullanmak daha kolay hale gelir.

- Responsive TasarÄ±m: Bootstrap'in temel Ã¶zelliklerinden biri, responsive (duyarlÄ±) tasarÄ±mÄ± desteklemesidir. Bu Ã¶zellik, uygulamanÄ±zÄ±n farklÄ± cihazlarda ve ekran boyutlarÄ±nda uyumlu bir ÅŸekilde gÃ¶rÃ¼ntÃ¼lenmesini saÄŸlar. React Bootstrap, Bootstrap'in responsive Ã¶zelliklerini korur ve React bileÅŸenleriyle birlikte kullanÄ±ldÄ±ÄŸÄ±nda bile duyarlÄ± bir kullanÄ±cÄ± arayÃ¼zÃ¼ oluÅŸturmanÄ±za yardÄ±mcÄ± olur.

- Kolay Ã–zelleÅŸtirme: React Bootstrap, Bootstrap bileÅŸenlerini kullanmanÄ±n yanÄ± sÄ±ra, bu bileÅŸenleri Ã¶zelleÅŸtirmenize de olanak tanÄ±r. Bootstrap'in CSS sÄ±nÄ±flarÄ± ve Ã¶zelleÅŸtirme seÃ§enekleri ile bileÅŸenlerin gÃ¶rÃ¼nÃ¼mÃ¼nÃ¼ ve davranÄ±ÅŸÄ±nÄ± kolayca deÄŸiÅŸtirebilirsiniz. AyrÄ±ca, React'in Ã¶zellikleri sayesinde bileÅŸenlerin durumunu ve davranÄ±ÅŸÄ±nÄ± programatik olarak yÃ¶netebilirsiniz.

React Bootstrap, React ve Bootstrap'i bir araya getirerek, gÃ¼Ã§lÃ¼ bir kullanÄ±cÄ± arayÃ¼zÃ¼ oluÅŸturma deneyimi sunar. React'in bileÅŸen tabanlÄ± yapÄ±sÄ±, Bootstrap bileÅŸenlerini daha modÃ¼ler hale getirir ve React'in gÃ¼Ã§lÃ¼ Ã¶zelliklerini kullanarak daha etkileÅŸimli ve dinamik bir kullanÄ±cÄ± arayÃ¼zÃ¼ oluÅŸturmanÄ±zÄ± saÄŸlar.

## Projemize nasÄ±l dahil edebiliriz?
```javascript
npm install react-bootstrap bootstrap
or
yarn add react-bootstrap bootstrap


// The following line can be included in your src/index.js or App.js file

import 'bootstrap/dist/css/bootstrap.min.css';
```

ArtÄ±k projemize eklediÄŸimize gÃ¶re hem bootstrap Ã¶zelliklerinden hem de react-bootstrap Ã¶zelliklerini kullanmaya baÅŸlayabiliriz. 

Ã–rneÄŸin; bir buton elementi oluÅŸturmak istiyorsunuz diyelim. Ã–ncelikle ilgili sayfamÄ±zda React-Bootstrapten `Button` componentini import ediyoruz.
```jsx
import Button from 'react-bootstrap/Button';
...
```
SonrasÄ±nda aynÄ± sayfa iÃ§erisinde artÄ±k Button componentini Ã§aÄŸÄ±rÄ±p kullanabiliriz.

```jsx
import Button from 'react-bootstrap/Button';

function MyButtonComp() {
  return (
    <>
      <Button variant="primary">Primary</Button>
      <Button variant="secondary">Secondary</Button>
      <Button variant="success">Success</Button>
      <Button variant="warning">Warning</Button>
      <Button variant="danger">Danger</Button>
      <Button variant="info">Info</Button>
      <Button variant="light">Light</Button>
      <Button variant="dark">Dark</Button>
      <Button variant="link">Link</Button>
    </>
  );
}

export default MyButtonComp;

```
Button componenti html button elementinin sahip olduÄŸu Ã¶zellikleri iÃ§erisinde barÄ±ndÄ±rÄ±yor. AynÄ± zamanda `btn` classÄ±nÄ±n sahip olduÄŸu css Ã¶zelliklerini iÃ§erisinde barÄ±ndÄ±rÄ±yor. React props mantÄ±ÄŸÄ±yla da `Button` componentine ek Ã¶zellikler kazandÄ±rabiliyoruz. React-Bootstrap componentlerinin alacaÄŸÄ± props isimleri sabit belirlenmiÅŸtir. BunlarÄ± dÃ¶kÃ¼mandan Ã¶ÄŸrenebiliriz ([Button Ã¶rneÄŸi iÃ§in tÄ±klayÄ±nÄ±z](https://react-bootstrap.netlify.app/docs/components/buttons#api)) veya node_modules klasÃ¶rÃ¼ iÃ§erisinden react-bootstrapi aÃ§Ä±p iÃ§erisinden ilgili componente bakabiliriz(DÃ¶kÃ¼mandan incelemenizi tavsiye ederim). 

### Responsive Grid yapÄ±sÄ±na Ã¶rnekler:

##### Col ile Responsive AyarÄ±
Col, 6 breakpoints boyutunda (xs, sm, md, lg, xl ve xxl) sÃ¼tun geniÅŸliklerini belirlemenizi saÄŸlar. Her breakpoints iÃ§in, yayÄ±lacak sÃ¼tun miktarÄ±nÄ± belirtebilirsiniz.(Ã–lÃ§Ã¼yÃ¼ dÃ¼z bootstrap mantÄ±ÄŸÄ±yla veriyoruz. Yani `col-sm-8` ile `sm={8}` aynÄ± Ã¶lÃ§Ã¼ye sahip olmuÅŸ oluyor. Yani sÃ¼tunun o satÄ±rda ne kadar yer kaplamasÄ±nÄ± istiyorsanÄ±z ona gÃ¶re deÄŸer veriyorsunuz. ) 
```jsx
import Container from 'react-bootstrap/Container';
import Row from 'react-bootstrap/Row';
import Col from 'react-bootstrap/Col';

function ResponsiveAutoExample() {
  return (
    <Container>
      <Row>
        <Col sm={8} md={6} lg={4}>sm=8-md=6-lg=4</Col>
        <Col sm={8} md={6} lg={4}>sm=4</Col>
      </Row>
    </Container>
  );
}

export default ResponsiveAutoExample;
```

##### Row'da Col GeniÅŸliklerini Ayarlama ile Responsive AyarÄ±

Row, 6 breakpoints boyutunda (xs, sm, md, lg, xl ve xxl) sÃ¼tun geniÅŸliklerini belirlemenizi saÄŸlar. Her breakpoints iÃ§in, yan yana sÄ±ÄŸacak sÃ¼tun miktarÄ±nÄ± belirleyebilirsiniz.(Ã–lÃ§Ã¼yÃ¼ satÄ±rda gÃ¶rÃ¼ntÃ¼lemek istediÄŸiniz sayÄ±ya gÃ¶re veriyorsunuz. Ã–rneÄŸin; xs ekranlarda her satÄ±rda 2 tane gÃ¶ster, md ekranlarda 4, lg ve sonrasÄ±nda 6tane gÃ¶ster.)
```jsx
import Container from 'react-bootstrap/Container';
import Row from 'react-bootstrap/Row';
import Col from 'react-bootstrap/Col';

function RowColLayoutExample() {
  return (
    <Container>
      <Row xs={2} md={4} lg={6}>
        <Col>1 of 2</Col>
        <Col>2 of 2</Col>
      </Row>
      <Row xs={1} md={2}>
        <Col>1 of 3</Col>
        <Col>2 of 3</Col>
        <Col>3 of 3</Col>
      </Row>
    </Container>
  );
}

export default RowColLayoutExample;
```

##### Default 6 Breakpoints

| Breakpoint           | Class infix | Dimensions |
|----------------------|-------------|------------|
| X-Small              | xs          | <576px     |
| Small                | sm          | â‰¥576px     |
| Medium               | md          | â‰¥768px     |
| Large                | lg          | â‰¥992px     |
| Extra large          | xl          | â‰¥1200px    |
| Extra extra large    | xxl         | â‰¥1400px    |


## Nba Legends

### [filter iÅŸlemi](./src/components/CardContainer.jsx)

- Ä°nputa girilen veriye gÃ¶re ekranda gÃ¶sterilen datanÄ±n deÄŸiÅŸmesi lazÄ±m. DatayÄ± ekrana nerede basÄ±yoruz ? CardContainer iÃ§erisinde. O zaman inputuda card container iÃ§erisinde oluÅŸturabiliriz.

- Burada biizm Ã¶rneÄŸimizde filtreleme iÅŸlemi oyuncularÄ±n name bilgisine gÃ¶re yapÄ±lÄ±yor. Peki name e gÃ¶re filtrelerken nasÄ±l bir yol izleyeceÄŸiz ?
- String metotlarÄ±nÄ± hatÄ±rlayalÄ±m. Bu metotlardan hangisi iÃ§erisine verdiÄŸimiz karakterleri iÃ§erip iÃ§ermediÄŸini kontrol ediyordu ? includes() metodu. Bu metot iÃ§erisine yazÄ±lan veriyi sorguladÄ±ÄŸÄ±mÄ±z string iÃ§eriyorsa true dÃ¶ner iÃ§ermiyorsa false dÃ¶ner. 

```javascript
  "araba".includes("a") => true
  "araba".includes("ar") => true
  "araba".includes("ara") => true
  "araba".includes("m") => false
```
- Biz de burada filtreleme iÅŸleminde sorgulayacaÄŸÄ±mÄ±z string name bilgisi olacak. name bilgisi inputta yazan veriyi iÃ§eriyorsa datayÄ± ona gÃ¶re filtrelemiÅŸ olacak. Ve bu kullanÄ±cÄ± her inputta deÄŸiÅŸiklik yaptÄ±ÄŸÄ±nda olmasÄ± gerekiyor. 
- Bu nedenle Ã¶nce bize ne lazÄ±m inputtan gelen veri. inputtan veriyi anlÄ±k olarak nasÄ±l yakalÄ±yoruz ? onChange eventiyle anlÄ±k olarak deÄŸiÅŸiklikleri yakalayabiliyoruz. onChange de veriyi yakaladÄ±k ama her deÄŸiÅŸikliÄŸi algÄ±layÄ±p bunu ekrana yansÄ±tacak bir ÅŸey lazÄ±m bize ama o ne ? Tabiki useState hooku. useState hooku reactta durum deÄŸiÅŸikliklerini takip eden ve o deÄŸiÅŸikliÄŸe gÃ¶re componenti yeniden render ettiren bir hook. 
```jsx
  const [search,setSearch] = useState("");

  ...

  return (
    <>
      <input type="search" onChange={(e)=> setSearch(e.target.value)}>
    </input>
  )
```
- O zaman biz de inputtan gelen veriyi state e aktarÄ±rsak her deÄŸiÅŸklikte componenti render ettirmiÅŸ oluruz. Component her render olduÄŸunda da filteredData yeniden oluÅŸturulacaÄŸÄ± iÃ§in yani yeniden tanÄ±mlanacaÄŸÄ± iÃ§in kolaylÄ±kla ekrandaki deÄŸiÅŸikliÄŸi saÄŸlamÄ±ÅŸ oluyoruz.

```jsx
const CardContainer = () => {
  const [search, setSearch] = useState("");

  const filteredData = data.filter(player =>
    player.name.toLowerCase().includes(search.trim().toLowerCase())
  );
   return (
    <>
      <Form.Control
        type="search"
        placeholder="Search player..."
        className="w-50 m-auto"
        onChange={e => setSearch(e.target.value)}
      />
      <Container className="card-container my-4 p-3 rounded-4">
        <Row sm={2} md={2} lg={3} xl={4} className="g-4 justify-content-center">
          {filteredData.map((player, i) => {
            return (
              <Col key={i}>
                <PlayerCard {...player} />
              </Col>
            );
          })}
        </Row>
      </Container>
    </>
  );
};

export default CardContainer;
```


### [Card GÃ¶sterilen Veriyi DeÄŸiÅŸtirme](./src/components/PlayerCard.jsx)

- Bizden beklenen her carda tÄ±klandÄ±ÄŸÄ±nda o cardda deÄŸiÅŸim olmasÄ±. Bizim Ã¶rneÄŸimizde resim yerine statistic bilgilerinin cardda gÃ¶sterilmesi veya tam tersi resmin cardda gÃ¶sterilmesi. 
- Ve her tÄ±klanÄ±ldÄ±ÄŸÄ±nda da ilgili cardÄ±n yeniden render olmasÄ± gerekiyor. Bunu da react da yapabilmek iÃ§in useState hookuna ihtiyacÄ±mÄ±z var. Ve sadece tÄ±klanan cardÄ±n deÄŸiÅŸmesi ve tekrar o carda tÄ±klanÄ±lana kadar deÄŸiÅŸimin sabit kalmasÄ± gerektiÄŸi iÃ§in her cardÄ±n kendine ait bir durumu olmasÄ± lazÄ±m. 
- Her cardÄ±n durumu olmasÄ± iÃ§in de datayÄ± maplediÄŸimizde her veri iÃ§in bir component return edersek her carda ait stateleri o component iÃ§erisinde oluÅŸturabiliriz. Ã‡Ã¼nkÃ¼ veri sayÄ±sÄ± ne kadarsa aslÄ±nda o kadar component oluÅŸturmuÅŸ olacaÄŸÄ±mÄ±z iÃ§in o component iÃ§erisinde oluÅŸturduÄŸumuz stateler fonksiyonlarda her veri iÃ§in ayrÄ± ayrÄ± tanÄ±mlanmÄ±ÅŸ olacak. BÃ¶ylelikle her carda ait durum oluÅŸturabilmiÅŸ olacaÄŸÄ±z. Aksi takdirde veriyi datayÄ± maplediÄŸimiz yerde ekrana bassak elimizde tek bir state olacaÄŸÄ± iÃ§in hangi carda tÄ±klarsak tÄ±klayalÄ±m hepsi deÄŸiÅŸecektir.

- Bu nedenle datayÄ± Ã¼st componentte mapleyip returnde her veri iÃ§in alt component olan PlayerCard componentini Ã§aÄŸÄ±rÄ±ÄŸ verileri props yoluyla ona gÃ¶ndereceÄŸiz.

```jsx
const CardContainer = () => {
  const [search, setSearch] = useState("");

  const filteredData = data.filter(player =>
    player.name.toLowerCase().includes(search.trim().toLowerCase())
  );
   return (
    <>
      <Form.Control
        type="search"
        placeholder="Search player..."
        className="w-50 m-auto"
        onChange={e => setSearch(e.target.value)}
      />
      <Container className="card-container my-4 p-3 rounded-4">
        <Row sm={2} md={2} lg={3} xl={4} className="g-4 justify-content-center">
          {filteredData.map((player, i) => {
            return (
              <Col key={i}>
                <PlayerCard {...player} />
              </Col>
            );
          })}
        </Row>
      </Container>
    </>
  );
};

export default CardContainer;
```

- Åimdi sÄ±ra her card iÃ§in durumlarÄ± oluÅŸturmaya geldi. Burada nasÄ±l bir durum oluÅŸturacaÄŸÄ±z ? Carda tÄ±klanÄ±ldÄ±ÄŸÄ±nda yazÄ±lar gelcek tekrar tÄ±klanÄ±ldÄ±ÄŸÄ±nda resimler gelecek. Bu deÄŸiÅŸikliÄŸi takip etmek iÃ§in useState e ihtiyacÄ±mÄ±z var. Ve deÄŸÅŸikliÄŸi yapabilmemiz iÃ§in onClick eventÄ±na ihtiyacÄ±mÄ±z var. 

```jsx
  const [showImg,setShowImg] = useState(true)
```

- State deÄŸiÅŸtikÃ§e ilgili component render edileceÄŸi iÃ§in bu state e gÃ¶re bir mekanizma oluÅŸturabiliriz. Bu mekanizmanÄ±n adÄ± reactta **conditional rendering** . Bunu da JSX iÃ§erisinde [ternary operator](https://react.dev/learn/conditional-rendering#conditional-ternary-operator--) ile yapabiliriz. Yani showImg statei true ise resim gÃ¶sterilecek eÄŸer false ise statisticler gÃ¶sterilecek. Peki deÄŸiÅŸim nasÄ±l olacak ? Yani click olduÄŸunda ne olmasÄ± gerekiyor. Ve click eventÄ±nÄ± nereye tanÄ±mlayacaÄŸÄ±z? Resme tÄ±klandÄ±ÄŸÄ±nda showImage false olacak, yazÄ±lara tÄ±klandÄ±ÄŸÄ±nda showImage true olacak. Peki ayrÄ± ayrÄ± onClick tanÄ±mlamak yerine bunu tek bir yerden tanÄ±mlayÄ±p hem resim olduÄŸunda hem yazÄ± olduÄŸunda aynÄ± click Ã§alÄ±ÅŸacak ve showImage stateini tam tersine Ã§evirebilir miyiz ? TAbi ki Ã§evirebiliriz. onClick eventÄ±na kapsayÄ±cÄ±ya verip ve onClick iÃ§erisinde de `not !` operatÃ¶rÃ¼nÃ¼n nimetlerinden yararlanÄ±rsak tek hamlede bu iÅŸlemi bitirebiliriz. Yani `setShowImage(!showImage)` dediÄŸimizde true ise false yapacak, false ise true yapacak.

```jsx
import React, { useState } from "react";
import Card from "react-bootstrap/Card";
const PlayerCard = ({ name, img, statistics }) => {
  const [showImage, setShowImage] = useState(true);
  const handleToggle = () => setShowImage(!showImage);
  return (
    <Card className="player-card" onClick={handleToggle} role="button">
      {showImage ? (
        <Card.Img variant="top" src={img} height={"350px"} />
      ) : (
        <ul className="m-auto">
          {statistics.map((item, i) => {
            return (
              <li key={i} className="h5 text-start list-unstyled">
                ğŸ€ {item}
              </li>
            );
          })}
        </ul>
      )}

      <Card.Footer>
        <Card.Title>{name}</Card.Title>
      </Card.Footer>
    </Card>
  );
};

export default PlayerCard;
```